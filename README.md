# Save-Share

A handheld-friendly game-save sharing client for KNULLI/Batocera-style H700 devices (Anbernic RG35XX/RG34XX family). The tool scans the on-device ROMs and saves, matches them to the EmulationStation `gamelist.xml`, hashes ROMs for cross-device identity, and talks to a Supabase backend to upload and download saves and savestates.

## Why Python CLI instead of a full SDL front-end?
The KNULLI PYGAME/Ports system can launch Python scripts easily, and a text UI is more robust for first-boot configuration on low-powered handhelds. The code is modular so a pygame/SDL overlay can be added later while reusing the scanning and Supabase modules.

## Features
- Centralized configuration for Supabase URL/key and filesystem paths.
- Parses every `gamelist.xml` to map ROM titles and locations.
- Hashes ROMs (MD5) to uniquely match saves across devices.
- Scans save and savestate folders, grouping by system and slot.
- Upload flow captures metadata (core, tags, description, nickname) and pushes to Supabase Storage + tables.
- Browse/download only shows saves for games you own locally (matched by system + ROM hash).
- Works offline for local scanning; online features fail gracefully.

## Repository layout
```
src/save_share/        # Python client modules
supabase/schema.sql    # Tables and view
supabase/policies.sql  # RLS policies
scripts/               # Helper or future automation hooks
config.example.json    # Generated by the client with defaults
```

## Client usage
Create a virtual environment (optional) and install dependencies:
```bash
python -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt  # or pip install requests
```

Run commands locally (defaults assume KNULLI paths):
```bash
python -m save_share index      # parse gamelists + hash ROMs
python -m save_share scan       # list detected saves/savestates
python -m save_share upload     # interactive upload of a local save/state
python -m save_share browse     # show matching remote saves
python -m save_share download   # choose and download a remote save
```

Flags:
- `--config <path>`: point to a custom `config.json`.

### Configuration
Copy and edit `config.json` (or run once to auto-generate `config.example.json`):
```json
{
  "supabase_url": "https://your-project.supabase.co",
  "supabase_key": "public-anon-key",
  "roms_path": "/userdata/roms",
  "saves_path": "/userdata/saves",
  "log_path": "/userdata/system/logs/save-share.log",
  "cache_path": "/userdata/system/configs/save-share/cache.json",
  "device_nickname": "rg35xx"
}
```

Adjust `roms_path`/`saves_path` if your firmware differs (e.g., `/userdata/bios/..` for some systems). The cache stores ROM hashes to avoid re-hashing.

### Packaging on KNULLI (PYGAME/Ports)
1. Copy the repository into `roms/ports/save-share/` (or any folder).
2. Create a launcher script `roms/ports/save-share/Save-Share.sh`:
   ```bash
   #!/bin/bash
   cd "$(dirname "$0")"
   /userdata/python/bin/python -m save_share "$@"
   ```
   Make it executable: `chmod +x Save-Share.sh`.
3. (Optional) Ship a `requirements.txt` with `requests` and install into the handheld’s Python (KNULLI ships Python; if not, bundle a portable interpreter or use PortMaster’s Python runtime).
4. Add a PNG logo to appear in EmulationStation if desired.

### Cross-compiling a native SDL front-end (future)
If you later replace the CLI with SDL/pygame visuals, use this structure:
```
roms/ports/save-share/
  Save-Share.sh         # launches the binary
  bin/save-share        # aarch64 binary
  assets/
```
Build hints:
- Use an aarch64-linux-gnu toolchain (Ubuntu package `gcc-aarch64-linux-gnu`).
- Set `CC=aarch64-linux-gnu-gcc` and `PKG_CONFIG_PATH` for SDL2/SDL2_image if cross-building.
- Target `-march=armv8-a` for Allwinner H700.
- Link statically where possible to reduce runtime deps.

## Supabase setup
1. Create a new project and note the **project URL** and **anon/public key**.
2. Run the SQL files in the SQL editor:
   - `supabase/schema.sql`
   - `supabase/policies.sql`
3. Create a Storage bucket named `saves` (public bucket is fine for anon download).
4. Optional: add Storage policy to allow insert/read with anon key.

### Storage layout
`saves/<system>/<rom_hash>/<save_id>.bin`

### REST calls the client uses
- Upsert game: `POST /rest/v1/games` with `{system, rom_hash, rom_name}` and `Prefer: return=representation`.
- Insert save metadata: `POST /rest/v1/saves` with `{game_id, save_type, core, tags, description, uploader_nickname, storage_path}`.
- List saves for local library: `GET /rest/v1/saves_view?system=in.(nes,snes)&rom_hash=in.(abcd,efgh)`.
- Download binary: `GET /storage/v1/object/saves/<path>` (Bearer = anon key).

## Handheld filesystem assumptions
- ROMs live under `/userdata/roms/<system>/` with a `gamelist.xml` per system (EmulationStation format).
- Saves live under `/userdata/saves/<system>/` with extensions like `.sav`, `.srm`, `.state`, `.state1`, etc.
- The tool matches saves by ROM basename and system, then uses ROM hashes for cross-device dedupe.

## Extending
- Add new tags or rating fields by altering the `saves` table (e.g., `rating smallint`).
- Swap MD5 for CRC32 in `rom_index.py` if you prefer faster hashes.
- Wire basic Supabase Auth by storing `device_nickname` or a UUID in `config.json` and sending it in metadata.

## Troubleshooting
- If Supabase calls fail on-device, confirm time/date (TLS) and that the anon key is correct.
- Use `python -m save_share index --config config.json` after adding new ROMs so hashes stay fresh.
- Delete the cache file to force a full re-hash if ROMs moved.
